<!DOCTYPE html>
<html>
<head>
<title>Zerg Battlefield Mapper</title>
	<link href="../exercises/exercise.css" rel="stylesheet" type="text/css"/>
	<style type="text/css" media="print">
<!--
		a:after {
			content: " ( " attr(href) " )"
		}
-->
	</style>
<style type="text/css">
<!--
	pre {
		page-break-inside: avoid;
	}
	table {
		border-collapse: collapse;
		table-layout: fixed;
		page-break-inside: avoid;
	}
	td, th {
		border: 1px solid black;
		padding: .5em .25em;
	}
-->
</style>
</head>
<body>

<article class="project">
	<h1>Zerg Mapper</h1>

	<p>The Zerg, uplifted race of the Xel'Naga, communicate via latent psychic
	abilities.  Surprisingly, these communications can be picked up via psychic
	antennae and recorded as standard UDP traffic.</p>

	<p>Your task is to write a progam that, given the psychic captures (PCAPs) of
	network traffic involving this fell race, determines where the zerg are
	located on the battlefield.  Some sample files are included for you.</p>

	<p>Each zerg can psychically communicate with other zerg that are within
	15.00000 meters of it.  As such, they form a mesh network of minds that can
	span the entire battlefield.  However, their psychic fields interfere at
	distances of less than 1.25000 yards, preventing either zerg from
	communicating with others of their race.  Removing one of the two will allow
	the other to start communicating psychically again.</p>

	<p>A <dfn>fully connected</dfn> zerg network includes a certain amount of
	redundancy.  Between any two zerg that are not directly adjacent (i.e.,
	within 15 meters of each other), there should be at least two disjoint routes.
	That is, given zergling A and zergling B, there are two different ways to get
	from A to B, with no zerg in common other than the endpoints.</p>

	<p>When fully connected, it may be possible to set up a pyschic resonance
	cascade that wipes out all the connected zerg.</p>

	<p>Your program should determine which zerg must be eliminated to set up this
	resonance cascade.  The goal should be to do this in the <strong>fewest
		changes possible</strong>.</p>

	<p>Additionally, Command wants to be alerted when any zerg's health
	drops below a certain percentage (default 10%).  Your program should
	provide a list of such zerg when it runs.</p>


	<h2>Packet Format</h2>

	<p><code>.pcap</code> files have a well-understood format.  They consist of a
	global header for the whole file, followed by a number of pcap-header/data
	sections.  A good reference is <a
		href="http://www.kroosec.com/2012/10/a-look-at-pcap-file-format.html">available
		for pcap format</a>.  Assume version 2.4.  Note that the <code>.pcap</code>
	packet captures provided do provide the Ethernet frame, IP header, and UDP
	header, but do not include the Preamble, Start-of-Frame, nor the FCS.
	Supporting Ethernet version II is required; but QoS data and 802.11 wireless is
	completely optional. Note that <code>.pcap</code> files may contain multiple
	captures.</p>

	<p><em>New from Previous Project</em>: Some of the zerg only broadcast over
	IPv6, so the <code>.pcap</code> files may be a mix of IPv4 and IPv6.  IPv6
	transitions such as 4in6, Teredo, etc. do <em>not</em> need to be supported
	in any way.</p>

	<p>The Zerg packet format is already well-documented.  However, the Zerg are
	attemping a rollout of a new packet format.  So, this program should only
	account for Version 1 of the psychic format (any Zerg using the new protocol
	have updated wetware, so they will neither cause nor be affected by the
	psychic interference). Zerg only operate over UDP, on port 3751.  All other
	transport/port traffic may be ignored.</p>

	<p>Sample <code>.pcap</code> files may be found in
	<code>/usr/local/share/instructor_share/zergmap/pcaps</code>
	on the class VM.  More may be added over time.  It is strongly recommended
	that you softlink to the directory rather than copying the files, in case
	any require updates.</p>


	<h2>Requirements</h2>

	<ol>
		<li>Your project must build on the class Virtual Machine.  If you are working
			primarily on another machine, <em>especially</em> one that is not Linux
			(OS X or Windows), <strong>make sure you test</strong> your ability to
			build well before the due date!</li>
		<li>Your project must build when <code>make</code> is invoked at the top-level
			directory.  It must also support the target <code>debug</code> to build a
			debugging version, the target <code>profile</code> to build a profiling
			version, and the target <code>clean</code> to clean up any files
			generated by <code>make</code>.</li>
		<li>The name of the binary built should be <code>zergmap</code>.</li>
		<li>The program should take any number of <code>.pcap</code> files as
		arguments, and scan all of them for evidence of Zerg soldiers.</li>
		<li>The program should accept an optional <code>-h</code> flag with an
			integer, which indicates the percent below which injured zerg IDs should
			be printed.</li>
		<li>If the number of adjustments to the network is greater than half of the
			starting number of Zerg with GPS data, then the program should report
			that too many changes are needed, rather than trying to make that many
			changes.</li>
	</ol>

	<h3  style="page-break-before: always">Sample Output</h3>

	<pre><samp>
<span class="prompt">&gt;</span> <kbd class="invoke">zergmap easy_1_solution/*.pcap</kbd>
Network Alterations:
Remove zerg #116087764

Low Health (10%):
zerg #116087764
zerg #338888228
zerg #1911165193

<span class="prompt">&gt;</span> <kbd class="invoke">zergmap -h 20 easy_0_solution/*.pcap</kbd>
ALL ZERG ARE IN POSITION

Low Health (20%):
zerg #439493451
zerg #515530019
zerg #1117142618
zerg #1231192379
zerg #1409959708
zerg #1631518149
</samp></pre>

	<h3>Due Date</h3>
	<p>The project is due at <strong>Friday, 17 February, 23:59EST</strong>.  No
	late work will be accepted.</p>

	<p>Your project should be stored in your github account, under the project
	name <code>zergmap</code>.  This repository will be pulled down at the due
	date.</p>

	<h3>Other Notes</h3>

	<p>The <code>.pcap</code> files will all be little-endian, the same as the
	target machine for the program.  You do not need to support a big-endian
	<code>.pcap</code> file, but doing so would be counted as a flourish.  Note,
	however, that even if the <code>.pcap</code> headers are little-endian, the
	data capture is <em>STILL</em> Big-Endian (network order)!</p>

	<p>Any variable-length portions of network headers (IP options, Ethernet 802x)
	do not need to be handled, and are purely optional.</p>

	<p>A combination of pcaps may have more than one solution, even more than one
	optimal solution.</p>

	<p>There may be other Zerg packets that are slightly malformed, or whose
	data makes no sense (8038&deg;N latitude, e.g.).  While you are free to ignore
	them, the program may not crash on them, and would be exemplary if such
	problematic packets were reported.</p>

	<p>Commit early and often.  As long as your program can build, consider
	committing, even if it has bugs.  Bugs only count against you in the
	finished product, not interstitial commits.</p>

	<p>Altitude is measured from sea level, and battlefields do sometimes have trenches.
	You may assume that the radius of the planet is a constant.  Which constant you pick
	is up to you, but consider carefully why you're picking it, and adding a comment
	as to why would be a very good move.  Zerg will not be more than 7 miles
	above or below sea level.</p>

	<p>You may further assume that the zerg communications are not impeded by
	walls, floors, bodies, fluids, and that they do not move about.  For now.</p>

	<h4 >Things You May Find Useful</h4>
	<ul>
		<li><code>gdb</code> for debugging</li>
		<li>The <code>codec</code> project that you have already built</li>
		<li>The <a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine</a> Formula</li>
		<li><code>git submodule</code> for your first project</li>
		<li>Stopping for the day when you are on a roll, rather than stuck</li>
		<li><a href="https://en.wikipedia.org/wiki/Suurballe%27s_algorithm">Suurballe's</a> Algorithm</li>
		<li>Attemping the easiest part first</li>
		<li>Taking a break when you are stuck, rather than on a roll</li>
		<li>Not attempting any extra features until the core requirements are done
			and checked in to your master branch.</li>
		<li><code>gdb</code> and a rubber duck</li>
		<li>Having a compilable, runnable program at all times</li>
		<li>An Adjacency List</li>
		<li>Working on extra features in separate branches until you are satisfied
			with them.</li>
		<li>R-trees</li>
		<li>Spending the first few hours reading up on these references and
		sketching out ideas, before beginning to code.</li>
		<li>An Adjacency Matrix</li>
		<li>Seriously, <code>gdb</code></li>
	</ul>

	<h4>Suggested Extras</h4>

	<p>Note that the goal is the fewest number of <em>changes</em>.  A company
	may be connectible by removing 10 zerg, but a simpler solution might be to
	<strong>add</strong> one instead.  So, let the program suggest adding
	additional zerg (specify location).  The number of changes (additions and
	deletions) should still be less than half the starting number of devices.</p>


	<ul>
		<li>Write a <code>man(1)</code> page for your program.</li>
		<li>Use degree symbols in output when adding zerg</li>
		<li>Some of the Zerg may have traffic on the network, but no packets
		that show their GPS data.  When such Zerg are detected, list them
		separately in the program output.</li>
		<li>Add a command-line parameter <code>-a</code> that makes the program
		only consider additions, and no removals.</li>
		<li>If your program supports additions and removals, add a command-line
		parameter <code>-r</code> that makes the program only consider removals,
		and no additions.</li>
	</ul>

	<p><strong>Challenge</strong>: For either command-line parameter, let it take
	an argument of how many devices to add or remove.  The program is welcome to
	say "No such solution found" if the solution is impossible.</p>

	<h3>Rubric</h3>
	<table>
		<tr>
			<th>Correct</th>
			<td>20%</td>
		</tr>
		<tr>
			<th>Architecture</th>
			<td>30%</td>
		</tr>
		<tr>
			<th>Efficient</th>
			<td>20%</td>
		</tr>
		<tr>
			<th>Idiomatic</th>
			<td>20%</td>
		</tr>
		<tr>
			<th>Writeup</th>
			<td>10%</td>
		</tr>
	</table>


	<h5>Final Wisdom</h5>
	<ul>
		<li>Algorithms and Data Structures are not about inventing solutions from
		whole cloth, but being able to find similar solutions and rework them.</li>
		<li>Being a programmer does not mean being a subject-matter expert in all
		things, just being able to fake it enough to turn it into a program.</li>
		<li>Remember when to optimize.</li>
		<li>You are not your code.</li>
	</ul>


</article>
</body>
</html>
